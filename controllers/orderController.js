// controllers/orderController.js

import Order from '../models/Order.js';
import Outlet from '../models/Outlet.js';
import User from '../models/User.js';
import OutletInventoryTransaction from '../models/OutletInventoryTransaction.js';
import Ingredient from '../models/Ingredient.js';
import { Roles } from '../constants/roles.js';
import { TransactionTypes } from '../constants/transactionTypes.js';
import { SourceTypes } from '../constants/sourceTypes.js';
import { OrderStatuses } from '../constants/orderStatuses.js'; // NEW: Import OrderStatuses
import mongoose from 'mongoose';

// Helper function to validate User references
const validateUserReference = async (userId, errorsArray, fieldName, requiredRole = null) => {
  if (!userId || !mongoose.Types.ObjectId.isValid(userId)) {
    errorsArray.push(`ID Pengguna tidak valid untuk ${fieldName}.`);
    return null;
  }
  const user = await User.findById(userId);
  if (!user || user.isDeleted || !user.isActive) {
    errorsArray.push(`Pengguna dengan ID '${userId}' untuk ${fieldName} tidak ditemukan, sudah dihapus, atau tidak aktif.`);
    return null;
  }
  if (requiredRole && !user.roles.includes(requiredRole)) {
    errorsArray.push(`Pengguna '${user.name}' (ID: '${userId}') untuk ${fieldName} bukan peran '${requiredRole}'.`);
    return null;
  }
  return { userId: user._id, name: user.name };
};

// --- CRUD Controller Functions for Order ---

// @desc    Create a new order (for ingredients from headquarters)
// @route   POST /api/v1/orders
// @access  Private (Operator role for placing, Admin for HQ)
export const createOrder = async (req, res) => {
  try {
    const { outletId, items } = req.body; // REMOVED: customerName, customerPhone
    const errors = [];
    let calculatedTotalPrice = 0; // Total cost of ordered ingredients

    // --- Validate Outlet ---
    let outletSnapshot;
    if (!outletId || !mongoose.Types.ObjectId.isValid(outletId)) {
      errors.push('ID Outlet tidak valid.');
    } else {
      const outlet = await Outlet.findById(outletId);
      if (!outlet || outlet.isDeleted || !outlet.isActive) {
        errors.push('Outlet yang disediakan tidak ditemukan, sudah dihapus, atau tidak aktif.');
      } else {
        outletSnapshot = {
          outletId: outlet._id,
          name: outlet.name,
          address: outlet.address // Include the full address subdocument
        };
      }
    }

    // --- Validate CreatedBy (User who placed the order - likely an Operator or Admin from an Outlet) ---
    let createdBySnapshot;
    if (!req.user || !req.user._id || !req.user.name) {
      errors.push('Informasi pengguna pembuat pesanan tidak tersedia. Pastikan pengguna terautentikasi.');
    } else {
      // Assuming operator/admin can place orders from an outlet
      const user = await validateUserReference(req.user._id, errors, 'pembuat pesanan');
      if (user) {
        createdBySnapshot = { userId: user.userId, name: user.name };
      }
    }

    // --- Validate and Process Order Items (Ingredients) ---
    const processedItems = [];
    if (!items || !Array.isArray(items) || items.length === 0) {
      errors.push('Daftar item pesanan (bahan) diperlukan.');
    } else {
      for (const item of items) {
        // Each item here is an ingredient being ordered
        if (!item.ingredientId || !mongoose.Types.ObjectId.isValid(item.ingredientId) || item.qty === undefined || item.qty < 1) {
          errors.push('Item pesanan memiliki format ID bahan atau jumlah yang tidak valid (minimal 1).');
          continue;
        }
        const ingredient = await Ingredient.findById(item.ingredientId);
        if (!ingredient || ingredient.isDeleted || !ingredient.isActive) {
          errors.push(`Bahan ID '${item.ingredientId}' tidak ditemukan, sudah dihapus, atau tidak aktif.`);
          continue;
        }

        processedItems.push({
          ingredientId: ingredient._id, // Store ingredient ID
          name: ingredient.name,       // Snapshot ingredient name
          unit: ingredient.unit,       // NEW: Snapshot ingredient unit
          qty: item.qty,
          price: ingredient.price,     // Snapshot ingredient price at time of order
          notes: item.notes || null,
          isAccepted: item.isAccepted || false, // Default to false
          outletInventoryTransactionId: null, // Initialize as null
        });
        // Calculate total price based on ingredient price
        calculatedTotalPrice += item.qty * ingredient.price;
      }
    }

    if (errors.length > 0) {
      return res.status(400).json({ message: 'Validasi gagal.', errors });
    }

    const orderData = {
      outlet: outletSnapshot,
      // REMOVED: customerName, customerPhone
      items: processedItems,
      totalPrice: calculatedTotalPrice,
      createdBy: createdBySnapshot,
      status: OrderStatuses.ORDERED, // MODIFIED: Default to 'ordered'
    };

    const order = await Order.create(orderData); // Code generated by pre-save hook
    res.status(201).json({
      message: 'Pesanan bahan berhasil dicatat.',
      order: order.toJSON()
    });

  } catch (error) {
    if (error.code === 11000) {
      const field = Object.keys(error.keyValue)[0];
      const value = error.keyValue[field];
      return res.status(409).json({ message: `Pesanan dengan ${field} '${value}' sudah ada.` });
    }
    if (error.name === 'ValidationError') {
      const errors = Object.keys(error.errors).map(key => error.errors[key].message);
      return res.status(400).json({ message: 'Validasi gagal.', errors });
    }
    console.error('Kesalahan saat membuat pesanan bahan:', error);
    res.status(500).json({ message: 'Kesalahan server saat membuat pesanan bahan.', error: error.message });
  }
};

// @desc    Get all orders (for ingredients)
// @route   GET /api/v1/orders
// @access  Private (Admin, SPV Area, Operator for their outlet)
export const getOrders = async (req, res) => {
  try {
    const filter = { isDeleted: false };
    const { outletId, status, dateFrom, dateTo } = req.query; // REMOVED: customerName

    if (outletId) {
      if (!mongoose.Types.ObjectId.isValid(outletId)) {
        return res.status(400).json({ message: 'ID Outlet tidak valid untuk filter.' });
      }
      filter['outlet.outletId'] = outletId;
    }
    if (status) {
      // MODIFIED: Validate against OrderStatuses enum values
      if (!Object.values(OrderStatuses).includes(status)) {
        return res.status(400).json({ message: 'Status pesanan tidak valid untuk filter.' });
      }
      filter.status = status;
    }
    // REMOVED: customerName filter
    if (dateFrom || dateTo) {
      filter.createdAt = {};
      if (dateFrom) {
        const d = new Date(dateFrom);
        if (isNaN(d.getTime())) { return res.status(400).json({ message: 'Format tanggal "dateFrom" tidak valid.' }); }
        filter.createdAt.$gte = d;
      }
      if (dateTo) {
        const d = new Date(dateTo);
        if (isNaN(d.getTime())) { return res.status(400).json({ message: 'Format tanggal "dateTo" tidak valid.' }); }
        filter.createdAt.$lte = new Date(d.getTime() + 24 * 60 * 60 * 1000 - 1);
      }
    }

    const orders = await Order.find(filter).sort({ createdAt: -1 });
    res.status(200).json(orders.map(order => order.toJSON()));
  } catch (error) {
    console.error('Kesalahan saat mengambil pesanan bahan:', error);
    res.status(500).json({ message: 'Kesalahan server saat mengambil pesanan bahan.', error: error.message });
  }
};

// @desc    Get a single order by ID (for ingredients)
// @route   GET /api/v1/orders/:id
// @access  Private (Admin, SPV Area, Operator for their outlet)
export const getOrderById = async (req, res) => {
  try {
    const { id } = req.params;
    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ message: 'Format ID Pesanan tidak valid.' });
    }

    const order = await Order.findById(id);

    if (!order || order.isDeleted === true) {
      return res.status(404).json({ message: 'Pesanan bahan tidak ditemukan atau sudah dihapus.' });
    }
    res.status(200).json(order.toJSON());
  } catch (error) {
    if (error.name === 'CastError' && error.kind === 'ObjectId') {
        return res.status(400).json({ message: 'Format ID Pesanan tidak valid.' });
    }
    console.error('Kesalahan saat mengambil pesanan bahan berdasarkan ID:', error);
    res.status(500).json({ message: 'Kesalahan server saat mengambil pesanan bahan berdasarkan ID.', error: error.message });
  }
};

// @desc    Update an order (e.g., status, accept items/ingredients by HQ)
// @route   PATCH /api/v1/orders/:id
// @access  Private (Admin, SPV Area for accepting items)
export const updateOrder = async (req, res) => {
  try {
    const { id } = req.params;
    const { status, items } = req.body; // Items here are the ingredient items being updated
    const errors = [];
    let createdInventoryTransactionId = null; // To store the ID of the new OIT for potential rollback

    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ message: 'Format ID Pesanan tidak valid.' });
    }

    const existingOrder = await Order.findById(id);
    if (!existingOrder || existingOrder.isDeleted) {
      return res.status(404).json({ message: 'Pesanan bahan tidak ditemukan atau sudah dihapus.' });
    }

    let updatedFields = {}; // Object to hold fields to be updated in the main order document

    // --- Handle Status Update ---
    if (status !== undefined) {
      // MODIFIED: Validate against OrderStatuses enum values
      if (!Object.values(OrderStatuses).includes(status)) {
        errors.push('Status pesanan tidak valid.');
      } else {
        updatedFields.status = status;
      }
    }

    // --- Handle Items Update (specifically for isAccepted and creating OutletInventoryTransaction) ---
    if (items !== undefined && Array.isArray(items)) {
        // Create a deep copy of existing items to modify
        const newItemsArray = existingOrder.items.map(item => item.toObject());

        // Snapshot of the user making the change for OutletInventoryTransaction.createdBy
        const createdBySnapshot = req.user ? { userId: req.user._id, name: req.user.name } : { userId: null, name: 'System' };

        for (const updatedItemRequest of items) {
            // Find the original item from the existing order based on its ingredientId
            const itemIndex = newItemsArray.findIndex(item => item.ingredientId.toString() === updatedItemRequest.ingredientId.toString());

            if (itemIndex === -1) {
                errors.push(`ID Bahan '${updatedItemRequest.ingredientId}' tidak ditemukan di pesanan asli.`);
                continue;
            }

            const existingItem = newItemsArray[itemIndex];

            // Only proceed if isAccepted is explicitly set to true AND it was previously false or unset
            if (updatedItemRequest.isAccepted === true && existingItem.isAccepted === false) {
                // Fetch the Ingredient details to get its current name, unit, and price
                const ingredientDoc = await Ingredient.findById(existingItem.ingredientId);
                if (!ingredientDoc || ingredientDoc.isDeleted || !ingredientDoc.isActive) {
                    errors.push(`Bahan '${existingItem.name}' (ID: '${existingItem.ingredientId}') tidak ditemukan, sudah dihapus, atau tidak aktif saat mencoba membuat transaksi inventori.`);
                    continue;
                }

                try {
                    const newTransaction = await OutletInventoryTransaction.create({
                        ingredient: {
                            ingredientId: ingredientDoc._id,
                            name: ingredientDoc.name,
                            unit: ingredientDoc.unit,
                        },
                        price: ingredientDoc.price, // Snapshot current price of the ingredient
                        outlet: {
                            outletId: existingOrder.outlet.outletId,
                            name: existingOrder.outlet.name,
                            address: existingOrder.outlet.address,
                        },
                        source: {
                            sourceType: SourceTypes.ORDER,
                            ref: existingOrder.code,
                        },
                        transactionType: TransactionTypes.IN, // Ingredients coming IN to outlet inventory
                        qty: existingItem.qty, // Quantity from the order item
                        notes: `Penerimaan bahan ${ingredientDoc.name} dari pesanan HQ (${existingOrder.code}).`,
                        createdBy: createdBySnapshot,
                        evidenceUrl: null, // No direct evidence for auto-generated transactions from order acceptance
                        isValid: true, // Auto-validated
                        isCalculated: false, // Pending calculation by inventory system
                    });
                    createdInventoryTransactionId = newTransaction._id; // Store for potential rollback

                    // Update the order item with the new transaction ID and set isAccepted to true
                    existingItem.isAccepted = true;
                    existingItem.outletInventoryTransactionId = createdInventoryTransactionId;

                } catch (trxError) {
                    console.error(`Error creating inventory transaction for ingredient ${ingredientDoc.name}:`, trxError);
                    errors.push(`Gagal membuat transaksi inventori untuk bahan '${ingredientDoc.name}' dari pesanan '${existingOrder.code}'.`);
                    createdInventoryTransactionId = null; // Clear if transaction creation failed
                }
            } else if (updatedItemRequest.isAccepted === false && existingItem.isAccepted === true) {
                // Prevent un-acceptance for now. If needed, this would involve reversing or invalidating the OIT.
                errors.push(`Tidak dapat mengubah status 'isAccepted' menjadi false untuk item bahan '${existingItem.name}' yang sudah diterima.`);
            }
            // Any other fields in updatedItemRequest (like qty, notes) are ignored for simplicity here
            // as the items array update is focused on 'isAccepted' and its side effects.
        } // End of updated items loop

        if (errors.length > 0) {
             // If any errors, attempt to clean up any single transaction that was successfully created
             if (createdInventoryTransactionId) {
                 try {
                     await OutletInventoryTransaction.findByIdAndDelete(createdInventoryTransactionId);
                     console.log(`Rolled back inventory transaction ${createdInventoryTransactionId} due to order update failure.`);
                 } catch (rollbackErr) {
                     console.error(`Failed to rollback inventory transaction ${createdInventoryTransactionId}:`, rollbackErr);
                 }
             }
            return res.status(400).json({ message: 'Validasi gagal pada item pesanan atau kesalahan transaksi inventori.', errors });
        }

        updatedFields.items = newItemsArray; // Update the items array in the main update object
    }

    if (errors.length > 0) {
      return res.status(400).json({ message: 'Validasi gagal.', errors });
    }

    const order = await Order.findByIdAndUpdate(
      id,
      { $set: updatedFields }, // Use $set to update specific fields
      { new: true, runValidators: true }
    );

    if (!order) {
      return res.status(404).json({ message: 'Pesanan bahan tidak ditemukan.' });
    }

    res.status(200).json({
      message: 'Pesanan bahan berhasil diperbarui.',
      order: order.toJSON()
    });

  } catch (error) {
    // If an unexpected error occurs during the process, attempt to clean up any created transaction
    if (createdInventoryTransactionId) {
        try {
            await OutletInventoryTransaction.findByIdAndDelete(createdInventoryTransactionId);
            console.log(`Rolled back inventory transaction ${createdInventoryTransactionId} due to unexpected error.`);
        } catch (rollbackErr) {
            console.error(`Failed to rollback inventory transaction ${createdInventoryTransactionId} on unexpected error:`, rollbackErr);
        }
    }
    if (error.name === 'CastError' && error.kind === 'ObjectId') {
        return res.status(400).json({ message: 'Format ID Pesanan tidak valid.' });
    }
    if (error.name === 'ValidationError') {
      const errors = Object.keys(error.errors).map(key => error.errors[key].message);
      return res.status(400).json({ message: 'Validasi gagal.', errors });
    }
    console.error('Kesalahan saat memperbarui pesanan bahan:', error);
    res.status(500).json({ message: 'Kesalahan server saat memperbarui pesanan bahan.', error: error.message });
  }
};


// @desc    Soft delete an order (Admin only)
// @route   DELETE /api/v1/orders/:id
// @access  Private (Admin role)
export const deleteOrder = async (req, res) => {
  try {
    const { id } = req.params;
    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ message: 'Format ID Pesanan tidak valid.' });
    }

    // Security check: Ensure only Admin can perform this soft delete
    if (!req.user || !req.user.roles || !req.user.roles.includes(Roles.admin)) {
       return res.status(403).json({ message: 'Anda tidak memiliki izin untuk menghapus pesanan bahan ini.' });
    }

    const order = await Order.findByIdAndUpdate(
      id,
      { isDeleted: true, deletedAt: new Date(), deletedBy: req.user._id },
      { new: true }
    );

    if (!order) {
      return res.status(404).json({ message: 'Pesanan bahan tidak ditemukan.' });
    }

    res.status(200).json({
      message: 'Pesanan bahan berhasil dihapus (soft delete).',
      order: order.toJSON()
    });
  } catch (error) {
    if (error.name === 'CastError' && error.kind === 'ObjectId') {
        return res.status(400).json({ message: 'Format ID Pesanan tidak valid.' });
    }
    console.error('Kesalahan saat menghapus pesanan bahan:', error);
    res.status(500).json({ message: 'Kesalahan server saat menghapus pesanan bahan.', error: error.message });
  }
};
