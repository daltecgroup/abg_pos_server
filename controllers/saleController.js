import Sale from '../models/Sale.js';
import Outlet from '../models/Outlet.js';
import User from '../models/User.js';
import { PaymentMethods } from '../constants/paymentMethods.js';
import { Roles } from '../constants/roles.js';
import mongoose from 'mongoose';
import multer from 'multer'; // Import multer for error handling
import * as saleProcessingService from '../services/saleProcessingService.js'; // NEW: Import the sale processing service


// Helper to validate User references (kept here as it's a general controller utility)
const validateUserReference = async (userId, errorsArray, fieldName, requiredRole = null) => {
  if (!userId || !mongoose.Types.ObjectId.isValid(userId)) {
    errorsArray.push(`ID Pengguna tidak valid untuk ${fieldName}.`);
    return null;
  }
  const user = await User.findById(userId);
  if (!user || user.isDeleted || !user.isActive) {
    errorsArray.push(`Pengguna dengan ID '${userId}' untuk ${fieldName} tidak ditemukan, sudah dihapus, atau tidak aktif.`);
    return null;
  }
  if (requiredRole && !user.roles.includes(requiredRole)) {
    errorsArray.push(`Pengguna '${user.name}' (ID: '${userId}') untuk ${fieldName} bukan peran '${requiredRole}'.`);
    return null;
  }
  return { userId: user._id, name: user.name }; // Return object with _id and name
};

// Helper for image upload path for payment evidence (kept here as it's related to multer middleware)
const getPaymentEvidenceUrl = (req) => {
  if (req.file) {
    // Assuming Multer and image processing middleware save to /uploads/payment_evidence
    return `/uploads/payment/evidence/${req.file.filename}`;
  }
  return null;
};

// --- CRUD Controller Functions for Sale ---

// @desc    Create a new sale
// @route   POST /api/sales
// @access  Private (Operator role)
export const createSale = async (req, res) => {
  try {
    const paymentEvidenceUrl = getPaymentEvidenceUrl(req);
  
    // Delegate processing and validation to the service
    const { saleData, errors } = await saleProcessingService.processNewSaleData(
        req.body,
        req.user, // Pass req.user for operator validation
        paymentEvidenceUrl
    );

    if (errors.length > 0) {
      // If a file was uploaded but validation fails, delete the uploaded file
      if (req.file) {
        const fs = await import('fs/promises');
        try {
          await fs.unlink(req.file.path);
          console.log(`Deleted redundant uploaded file: ${req.file.path}`);
        } catch (fileErr) {
          console.error(`Error deleting redundant file ${req.file.path}:`, fileErr);
        }
      }
      return res.status(400).json({ message: 'Validasi gagal.', errors });
    }

    const sale = await Sale.create(saleData); // Code will be generated by pre-save hook
    res.status(201).json({
      message: 'Penjualan berhasil dicatat.',
      sale: sale.toJSON()
    });

  } catch (error) {
    // If a file was uploaded but an unexpected error occurs, delete the uploaded file
    if (req.file) {
      const fs = await import('fs/promises');
      try {
        await fs.unlink(req.file.path);
        console.log(`Deleted redundant uploaded file: ${req.file.path}`);
      } catch (fileErr) {
        console.error(`Error deleting redundant file ${req.file.path}:`, fileErr);
      }
    }
    if (error.code === 11000) {
      const field = Object.keys(error.keyValue)[0];
      const value = error.keyValue[field];
      return res.status(409).json({ message: `Penjualan dengan ${field} '${value}' sudah ada.` });
    }
    if (error.name === 'ValidationError') {
      const errors = Object.keys(error.errors).map(key => error.errors[key].message);
      return res.status(400).json({ message: 'Validasi gagal.', errors });
    }
    // Handle Multer-specific errors
    if (error instanceof multer.MulterError) {
      if (error.code === 'LIMIT_FILE_SIZE') {
        return res.status(400).json({ message: 'Ukuran file terlalu besar. Maksimal 10MB.' });
      }
      return res.status(400).json({ message: `Kesalahan unggah file: ${error.message}` });
    }
    if (error.message.includes('Hanya file gambar')) { // Custom fileFilter error
      return res.status(400).json({ message: error.message });
    }
    console.error('Kesalahan saat membuat penjualan:', error);
    res.status(500).json({ message: 'Kesalahan server saat membuat penjualan.', error: error.message });
  }
};

// @desc    Get all sales
// @route   GET /api/sales
// @access  Private (Admin, SPV Area)
export const getSales = async (req, res) => {
  try {
    const filter = { isDeleted: false };
    const { outletId, operatorId, dateFrom, dateTo, isValid, paymentMethod } = req.query;

    if (outletId) {
      if (!mongoose.Types.ObjectId.isValid(outletId)) {
        return res.status(400).json({ message: 'ID Outlet tidak valid untuk filter.' });
      }
      filter['outlet.outletId'] = outletId;
    }
    if (operatorId) {
      if (!mongoose.Types.ObjectId.isValid(operatorId)) {
        return res.status(400).json({ message: 'ID Operator tidak valid untuk filter.' });
      }
      filter['operator.operatorId'] = operatorId;
    }
    if (dateFrom || dateTo) {
      filter.createdAt = {}; // Filter by createdAt for sale date
      if (dateFrom) {
        const d = new Date(dateFrom);
        if (isNaN(d.getTime())) { return res.status(400).json({ message: 'Format tanggal "dateFrom" tidak valid.' }); }
        filter.createdAt.$gte = d;
      }
      if (dateTo) {
        const d = new Date(dateTo);
        if (isNaN(d.getTime())) { return res.status(400).json({ message: 'Format tanggal "dateTo" tidak valid.' }); }
        filter.createdAt.$lte = new Date(d.getTime() + 24 * 60 * 60 * 1000 - 1); // Up to the last millisecond of dateTo
      }
    }
    if (isValid !== undefined) {
      filter.isValid = isValid === 'true';
    }
    if (paymentMethod) {
        if (!Object.values(PaymentMethods).includes(paymentMethod)) {
            return res.status(400).json({ message: 'Metode pembayaran tidak valid untuk filter.' });
        }
        filter['payment.method'] = paymentMethod;
    }


    const sales = await Sale.find(filter).sort({ createdAt: -1 });
    res.status(200).json(sales.map(sale => sale.toJSON()));
  } catch (error) {
    console.error('Kesalahan saat mengambil penjualan:', error);
    res.status(500).json({ message: 'Kesalahan server saat mengambil penjualan.', error: error.message });
  }
};

// @desc    Get a single sale by ID
// @route   GET /api/sales/:id
// @access  Private (Admin, SPV Area, Operator - operator can only view their own outlet's sales)
export const getSaleById = async (req, res) => {
  try {
    const { id } = req.params;
    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ message: 'Format ID Penjualan tidak valid.' });
    }

    const sale = await Sale.findById(id);

    if (!sale || sale.isDeleted === true) {
      return res.status(404).json({ message: 'Penjualan tidak ditemukan atau sudah dihapus.' });
    }

    // Optional Security: If req.user is operator, check if outlet matches
    // if (req.user && req.user.roles.includes(Roles.operator)) {
    //     // Assuming req.user has outletId or you fetch it here
    //     const operatorOutlet = await Outlet.findOne({ operators: req.user._id, isDeleted: false });
    //     if (!operatorOutlet || operatorOutlet._id.toString() !== sale.outlet.outletId.toString()) {
    //         return res.status(403).json({ message: 'Anda tidak diizinkan untuk melihat penjualan ini.' });
    //     }
    // }

    res.status(200).json(sale.toJSON());
  } catch (error) {
    if (error.name === 'CastError' && error.kind === 'ObjectId') {
        return res.status(400).json({ message: 'Format ID Penjualan tidak valid.' });
    }
    console.error('Kesalahan saat mengambil penjualan berdasarkan ID:', error);
    res.status(500).json({ message: 'Kesalahan server saat mengambil penjualan berdasarkan ID.', error: error.message });
  }
};

// @desc    Update a sale (e.g., mark as invalid, add print history)
// @route   PATCH /api/sales/:id
// @access  Private (Admin, or specific roles for certain updates like isValid)
export const updateSale = async (req, res) => {
  try {
    const { id } = req.params;
    const updateData = { ...req.body };
    const errors = [];

    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ message: 'Format ID Penjualan tidak valid.' });
    }

    const existingSale = await Sale.findById(id);
    if (!existingSale || existingSale.isDeleted) {
      return res.status(404).json({ message: 'Penjualan tidak ditemukan atau sudah dihapus.' });
    }

    // --- Validation for fields that can be updated ---
    if (updateData.isValid !== undefined && typeof updateData.isValid !== 'boolean') {
      errors.push('Nilai "isValid" harus berupa boolean.');
    }
    if (updateData.totalPaid !== undefined && (typeof updateData.totalPaid !== 'number' || updateData.totalPaid < 0)) {
      errors.push('Jumlah dibayar ("totalPaid") harus berupa angka non-negatif.');
    }
    if (updateData.payment && updateData.payment.method !== undefined && !Object.values(PaymentMethods).includes(updateData.payment.method)) {
      errors.push('Metode pembayaran tidak valid.');
    }

    // Handle invoicePrintHistory addition
    if (updateData.addInvoicePrintHistory) { // Custom field to trigger this action
        const userId = req.user?._id; // Assuming user ID from auth
        if (!userId) {
            errors.push('ID Pengguna tidak tersedia untuk catatan riwayat cetak faktur.');
        } else {
            const userDetails = await validateUserReference(userId, errors, 'riwayat cetak faktur');
            if (userDetails) {
                // Ensure invoicePrintHistory array exists
                if (!existingSale.invoicePrintHistory) {
                    existingSale.invoicePrintHistory = [];
                }
                existingSale.invoicePrintHistory.push({
                    userId: userDetails.userId,
                    printedAt: new Date(),
                });
                existingSale.save();
                // Remove the custom trigger field
                delete updateData.addInvoicePrintHistory;
            }
        }
    }

    if (errors.length > 0) {
      return res.status(400).json({ message: 'Validasi gagal.', errors });
    }

    // Apply updates (excluding the custom trigger field)
    const sale = await Sale.findByIdAndUpdate(
      id,
      { $set: updateData }, // Use $set to update specific fields, preserving others
      { new: true, runValidators: true } // runValidators for schema level validation
    );

    res.status(200).json({
      message: 'Penjualan berhasil diperbarui.',
      sale: sale.toJSON()
    });

  } catch (error) {
    if (error.name === 'CastError' && error.kind === 'ObjectId') {
        return res.status(400).json({ message: 'Format ID Penjualan tidak valid.' });
    }
    if (error.name === 'ValidationError') {
      const errors = Object.keys(error.errors).map(key => error.errors[key].message);
      return res.status(400).json({ message: 'Validasi gagal.', errors });
    }
    console.error('Kesalahan saat memperbarui penjualan:', error);
    res.status(500).json({ message: 'Kesalahan server saat memperbarui penjualan.', error: error.message });
  }
};

// @desc    Soft delete a sale (Admin only)
// @route   DELETE /api/sales/:id
// @access  Private (Admin role)
export const deleteSale = async (req, res) => {
  try {
    const { id } = req.params;
    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ message: 'Format ID Penjualan tidak valid.' });
    }

    // Security check: Ensure only Admin can perform this soft delete
    if (!req.user || !req.user.roles || !req.user.roles.includes(Roles.admin)) {
       return res.status(403).json({ message: 'Anda tidak memiliki izin untuk menghapus penjualan ini.' });
    }

    const sale = await Sale.findByIdAndUpdate(
      id,
      { isDeleted: true, deletedAt: new Date(), deletedBy: req.user._id },
      { new: true }
    );

    if (!sale) {
      return res.status(404).json({ message: 'Penjualan tidak ditemukan.' });
    }

    res.status(200).json({
      message: 'Penjualan berhasil dihapus (soft delete).',
      sale: sale.toJSON()
    });
  } catch (error) {
    if (error.name === 'CastError' && error.kind === 'ObjectId') {
        return res.status(400).json({ message: 'Format ID Penjualan tidak valid.' });
    }
    console.error('Kesalahan saat menghapus penjualan:', error);
    res.status(500).json({ message: 'Kesalahan server saat menghapus penjualan.', error: error.message });
  }
};
